import { getSandbox, Sandbox } from "@cloudflare/sandbox";
import { Hono } from "hono";
import { cors } from "hono/cors";
import { createMiddleware } from "hono/factory";

interface FileEntry {
  name: string;
  type: "directory" | "file";
  size: number;
  modified: string;
}

// Env type comes from worker-configuration.d.ts (generated by wrangler types)
const app = new Hono<{ Bindings: Env }>();

// Bearer token authentication middleware
const bearerAuth = createMiddleware<{ Bindings: Env }>(async (c, next) => {
  const authHeader = c.req.header("Authorization");
  if (!authHeader?.startsWith("Bearer ")) {
    return c.json({ error: "Unauthorized" }, 401);
  }
  const token = authHeader.slice(7);
  if (token !== c.env.API_TOKEN) {
    return c.json({ error: "Unauthorized" }, 401);
  }
  await next();
});

// CORS for HTTP endpoints
app.use("*", cors());

// Protected routes require bearer token
app.use("/ws", bearerAuth);
app.use("/files/:sessionId", bearerAuth);
app.use("/logs/:sessionId", bearerAuth);
app.use("/debug/:sessionId", bearerAuth);

// Health check endpoint (no auth required)
app.get("/health", (c) => {
  return c.json({
    status: "ok",
    service: "sandbox-worker",
    timestamp: new Date().toISOString(),
  });
});

// List files in session's .claude/projects/-workspace directories
app.get("/files/:sessionId", async (c) => {
  const sessionId = c.req.param("sessionId");
  const sandbox = getSandbox(c.env.Sandbox, sessionId, { sleepAfter: "10m" });
  const isProduction = c.env.ENVIRONMENT === "production";

  // Mount R2 bucket only in production
  if (isProduction) {
    const mountCheck = await sandbox.exec(
      "mountpoint -q /persistent && echo 'MOUNTED' || echo 'NOT_MOUNTED'",
    );
    if (mountCheck.stdout.includes("NOT_MOUNTED")) {
      await sandbox.mountBucket("claude-sessions", "/persistent", {
        endpoint: `https://${c.env.CF_ACCOUNT_ID}.r2.cloudflarestorage.com`,
      });
    }
  }

  // List files in workspace project directory
  const persistentPath = `/persistent/${sessionId}/.claude/projects/-workspace`;
  const localPath = "/root/.claude/projects/-workspace";

  // Use find with specific format for easy parsing
  const listCmd = (path: string): string => `
    if [ -d "${path}" ]; then
      find "${path}" -maxdepth 2 -printf '%y %s %T@ %P\\n' 2>/dev/null || echo ""
    else
      echo "DIR_NOT_FOUND"
    fi
  `;

  // Only query persistent storage in production
  const [persistentResult, localResult] = await Promise.all([
    isProduction
      ? sandbox.exec(listCmd(persistentPath))
      : Promise.resolve({ stdout: "DIR_NOT_FOUND" }),
    sandbox.exec(listCmd(localPath)),
  ]);

  const parseOutput = (output: string): FileEntry[] => {
    if (output.trim() === "DIR_NOT_FOUND" || !output.trim()) {
      return [];
    }
    return output
      .trim()
      .split("\n")
      .filter(Boolean)
      .map((line) => {
        const [type, size, mtime, ...pathParts] = line.split(" ");
        const path = pathParts.join(" ");
        return {
          name: path || ".",
          type: type === "d" ? ("directory" as const) : ("file" as const),
          size: Number.parseInt(size, 10),
          modified: new Date(Number.parseFloat(mtime) * 1000).toISOString(),
        };
      });
  };

  return c.json({
    sessionId,
    persistent: parseOutput(persistentResult.stdout),
    local: parseOutput(localResult.stdout),
  });
});

// Get container logs for a session
app.get("/logs/:sessionId", async (c) => {
  const sessionId = c.req.param("sessionId");
  const sandbox = getSandbox(c.env.Sandbox, sessionId, { sleepAfter: "10m" });

  const result = await sandbox.exec("cat /tmp/server.log 2>/dev/null || echo 'No logs yet'");
  return c.text(result.stdout);
});

// Debug endpoint to check session restoration state
app.get("/debug/:sessionId", async (c) => {
  const sessionId = c.req.param("sessionId");
  const sandbox = getSandbox(c.env.Sandbox, sessionId, { sleepAfter: "10m" });
  const isProduction = c.env.ENVIRONMENT === "production";

  // Mount R2 if production and not mounted
  if (isProduction) {
    const mountCheck = await sandbox.exec(
      "mountpoint -q /persistent && echo 'MOUNTED' || echo 'NOT_MOUNTED'",
    );
    if (mountCheck.stdout.includes("NOT_MOUNTED")) {
      await sandbox.mountBucket("claude-sessions", "/persistent", {
        endpoint: `https://${c.env.CF_ACCOUNT_ID}.r2.cloudflarestorage.com`,
      });
    }
  }

  // Get restoration logs and current state
  const [restoreLogs, currentState] = await Promise.all([
    sandbox.exec("cat /tmp/restore.log 2>/dev/null || echo 'No restore log yet'"),
    sandbox.exec(`
      echo "=== Current State ==="
      echo "R2 (/persistent/${sessionId}/.claude):"
      ls -la /persistent/${sessionId}/.claude 2>/dev/null || echo "  Not found"
      echo ""
      echo "Local (/root/.claude):"
      ls -la /root/.claude 2>/dev/null || echo "  Not found"
    `),
  ]);

  return c.json({
    sessionId,
    environment: c.env.ENVIRONMENT ?? "not set",
    isProduction,
    restoreLogs: restoreLogs.stdout,
    currentState: currentState.stdout,
  });
});

// WebSocket upgrade endpoint - proxies to the container's Claude Agent SDK server
app.get("/ws", async (c) => {
  console.log("[/ws] WebSocket upgrade request received");

  // Check for WebSocket upgrade
  const upgradeHeader = c.req.header("Upgrade");
  if (upgradeHeader !== "websocket") {
    console.log("[/ws] Not a WebSocket upgrade request");
    return c.json({ error: "Expected WebSocket upgrade" }, 426);
  }

  // Create a sandbox instance for this connection
  // Use session ID from query parameter or generate a new one
  const sessionId = c.req.query("sessionId") ?? "ws";
  console.log("[/ws] Creating sandbox with sessionId:", sessionId);
  const sandbox = getSandbox(c.env.Sandbox, sessionId, { sleepAfter: "10m" });

  const isProduction = c.env.ENVIRONMENT === "production";

  // Set environment variables FIRST (AWS creds needed for bucket mount)
  await sandbox.setEnvVars({
    ANTHROPIC_API_KEY: c.env.ANTHROPIC_API_KEY,
    AWS_ACCESS_KEY_ID: c.env.AWS_ACCESS_KEY_ID,
    AWS_SECRET_ACCESS_KEY: c.env.AWS_SECRET_ACCESS_KEY,
    ENVIRONMENT: c.env.ENVIRONMENT ?? "development",
  });
  console.log("[/ws] Environment variables set");

  // Mount R2 bucket for session persistence (production only)
  if (isProduction) {
    const mountCheck = await sandbox.exec(
      "mountpoint -q /persistent && echo 'MOUNTED' || echo 'NOT_MOUNTED'",
    );
    if (mountCheck.stdout.includes("NOT_MOUNTED")) {
      await sandbox.mountBucket("claude-sessions", "/persistent", {
        endpoint: `https://${c.env.CF_ACCOUNT_ID}.r2.cloudflarestorage.com`,
      });
      console.log("[/ws] R2 bucket mounted at /persistent");
    } else {
      console.log("[/ws] /persistent already mounted");
    }

    // Restore session from persistent storage if not already present locally
    const restoreResult = await sandbox.exec(`
      LOG="/tmp/restore.log"
      PERSISTENT_DIR="/persistent/${sessionId}/.claude"
      LOCAL_DIR="/root/.claude"

      echo "=== Restoration started at $(date) ===" > $LOG
      echo "Session ID: ${sessionId}" >> $LOG
      echo "ENVIRONMENT: $ENVIRONMENT" >> $LOG
      echo "" >> $LOG

      echo "=== Checking /persistent mount ===" >> $LOG
      mountpoint /persistent >> $LOG 2>&1 || echo "/persistent is not a mountpoint" >> $LOG
      ls -la /persistent 2>&1 | head -20 >> $LOG
      echo "" >> $LOG

      echo "=== Checking R2 persistent dir ===" >> $LOG
      ls -la "$PERSISTENT_DIR" 2>&1 >> $LOG
      echo "" >> $LOG

      echo "=== Checking local dir ===" >> $LOG
      ls -la "$LOCAL_DIR" 2>&1 >> $LOG
      echo "" >> $LOG

      # Always sync from R2 if data exists (rsync efficiently skips unchanged files)
      mkdir -p "$LOCAL_DIR"
      if [ -d "$PERSISTENT_DIR" ] && [ -n "$(ls -A $PERSISTENT_DIR 2>/dev/null)" ]; then
        echo "Syncing from R2..." >> $LOG
        if rsync -av "$PERSISTENT_DIR/" "$LOCAL_DIR/" >> $LOG 2>&1; then
          if [ -n "$(ls -A $LOCAL_DIR 2>/dev/null)" ]; then
            echo "RESTORED" | tee -a $LOG
          else
            echo "RESTORE_VERIFY_FAILED" | tee -a $LOG
          fi
        else
          echo "RESTORE_RSYNC_FAILED" | tee -a $LOG
        fi
      else
        echo "NO_R2_DATA" | tee -a $LOG
      fi

      echo "" >> $LOG
      echo "=== Final state ===" >> $LOG
      echo "Local:" >> $LOG
      ls -la "$LOCAL_DIR" 2>&1 >> $LOG
    `);
    const restoreStatus = restoreResult.stdout.trim();
    if (restoreStatus === "RESTORED") {
      console.log("[/ws] Session synced from R2 for:", sessionId);
    } else if (restoreStatus === "RESTORE_RSYNC_FAILED") {
      console.error("[/ws] Failed to restore session - rsync error for:", sessionId);
      return c.json({ error: "Failed to restore session data from storage" }, 503);
    } else if (restoreStatus === "RESTORE_VERIFY_FAILED") {
      console.error("[/ws] Failed to restore session - verification failed for:", sessionId);
      return c.json({ error: "Session restoration verification failed" }, 503);
    } else {
      console.log("[/ws] No R2 data to restore for:", sessionId);
    }
  } else {
    console.log("[/ws] Skipping R2 mount/restore (development mode)");
  }

  // Start container server using startProcess (inherits env vars from setEnvVars)
  const process = await sandbox.startProcess("bun /workspace/dist/index.js");
  console.log("[/ws] Process started with ID:", process.id);

  // Wait for server to be ready on port 8080
  try {
    await process.waitForPort(8080, { timeout: 30000, path: "/health" });
    console.log("[/ws] Server ready on port 8080");
  } catch (error) {
    console.log("[/ws] Server failed to start:", error);
    const logs = await sandbox.getProcessLogs(process.id);
    console.log("[/ws] Process logs:", logs);
    return c.json(
      {
        error: "Container server failed to start",
        logs: logs,
      },
      503,
    );
  }

  // Proxy the WebSocket connection to the container's server on port 8080
  return sandbox.wsConnect(c.req.raw, 8080);
});

export default app;
export { Sandbox };
