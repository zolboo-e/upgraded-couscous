import { getSandbox, Sandbox } from "@cloudflare/sandbox";
import { Hono } from "hono";
import { cors } from "hono/cors";
import { createMiddleware } from "hono/factory";

interface FileEntry {
  name: string;
  type: "directory" | "file";
  size: number;
  modified: string;
}

// Env type comes from worker-configuration.d.ts (generated by wrangler types)
const app = new Hono<{ Bindings: Env }>();

// Bearer token authentication middleware
const bearerAuth = createMiddleware<{ Bindings: Env }>(async (c, next) => {
  const authHeader = c.req.header("Authorization");
  if (!authHeader?.startsWith("Bearer ")) {
    return c.json({ error: "Unauthorized" }, 401);
  }
  const token = authHeader.slice(7);
  if (token !== c.env.API_TOKEN) {
    return c.json({ error: "Unauthorized" }, 401);
  }
  await next();
});

// CORS for HTTP endpoints
app.use("*", cors());

// Protected routes require bearer token
app.use("/ws", bearerAuth);
app.use("/files/:sessionId", bearerAuth);

// Health check endpoint (no auth required)
app.get("/health", (c) => {
  return c.json({
    status: "ok",
    service: "sandbox-worker",
    timestamp: new Date().toISOString(),
  });
});

// List files in session's .claude directories
app.get("/files/:sessionId", async (c) => {
  const sessionId = c.req.param("sessionId");

  // Get sandbox instance for this session
  const sandbox = getSandbox(c.env.Sandbox, sessionId);

  // Mount R2 bucket if not already mounted
  const mountCheck = await sandbox.exec(
    "mountpoint -q /persistent && echo 'MOUNTED' || echo 'NOT_MOUNTED'",
  );
  if (mountCheck.stdout.includes("NOT_MOUNTED")) {
    await sandbox.mountBucket("claude-sessions", "/persistent", {
      endpoint: `https://${c.env.CF_ACCOUNT_ID}.r2.cloudflarestorage.com`,
    });
  }

  // List files in both directories
  const persistentPath = `/persistent/${sessionId}/.claude`;
  const localPath = "/root/.claude";

  // Use find with specific format for easy parsing
  const listCmd = (path: string): string => `
    if [ -d "${path}" ]; then
      find "${path}" -maxdepth 2 -printf '%y %s %T@ %P\\n' 2>/dev/null || echo ""
    else
      echo "DIR_NOT_FOUND"
    fi
  `;

  const [persistentResult, localResult] = await Promise.all([
    sandbox.exec(listCmd(persistentPath)),
    sandbox.exec(listCmd(localPath)),
  ]);

  const parseOutput = (output: string): FileEntry[] => {
    if (output.trim() === "DIR_NOT_FOUND" || !output.trim()) {
      return [];
    }
    return output
      .trim()
      .split("\n")
      .filter(Boolean)
      .map((line) => {
        const [type, size, mtime, ...pathParts] = line.split(" ");
        const path = pathParts.join(" ");
        return {
          name: path || ".",
          type: type === "d" ? ("directory" as const) : ("file" as const),
          size: Number.parseInt(size, 10),
          modified: new Date(Number.parseFloat(mtime) * 1000).toISOString(),
        };
      });
  };

  return c.json({
    sessionId,
    persistent: parseOutput(persistentResult.stdout),
    local: parseOutput(localResult.stdout),
  });
});

// WebSocket upgrade endpoint - proxies to the container's Claude Agent SDK server
app.get("/ws", async (c) => {
  console.log("[/ws] WebSocket upgrade request received");

  // Check for WebSocket upgrade
  const upgradeHeader = c.req.header("Upgrade");
  if (upgradeHeader !== "websocket") {
    console.log("[/ws] Not a WebSocket upgrade request");
    return c.json({ error: "Expected WebSocket upgrade" }, 426);
  }

  // Create a sandbox instance for this connection
  // Use session ID from query parameter or generate a new one
  const sessionId = c.req.query("sessionId") ?? "ws";
  console.log("[/ws] Creating sandbox with sessionId:", sessionId);
  const sandbox = getSandbox(c.env.Sandbox, sessionId);

  // Set environment variables FIRST (AWS creds needed for bucket mount)
  await sandbox.setEnvVars({
    ANTHROPIC_API_KEY: c.env.ANTHROPIC_API_KEY,
    AWS_ACCESS_KEY_ID: c.env.AWS_ACCESS_KEY_ID,
    AWS_SECRET_ACCESS_KEY: c.env.AWS_SECRET_ACCESS_KEY,
  });
  console.log("[/ws] Environment variables set");

  // Mount R2 bucket for session persistence
  const mountCheck = await sandbox.exec(
    "mountpoint -q /persistent && echo 'MOUNTED' || echo 'NOT_MOUNTED'",
  );
  if (mountCheck.stdout.includes("NOT_MOUNTED")) {
    await sandbox.mountBucket("claude-sessions", "/persistent", {
      endpoint: `https://${c.env.CF_ACCOUNT_ID}.r2.cloudflarestorage.com`,
    });
    console.log("[/ws] R2 bucket mounted at /persistent");
  } else {
    console.log("[/ws] /persistent already mounted");
  }

  // Ensure required directories exist for Claude Agent SDK
  // await sandbox.exec("mkdir -p /etc/claude-code/.claude/skills /root/.claude/skills");

  // Restore session from persistent storage if not already present locally
  const restoreResult = await sandbox.exec(`
    if [ ! -d "/root/.claude" ] || [ -z "$(ls -A /root/.claude 2>/dev/null)" ]; then
      if [ -d "/persistent/${sessionId}/.claude" ]; then
        mkdir -p /root/.claude
        rsync -a /persistent/${sessionId}/.claude/ /root/.claude/ 2>/dev/null || true
        echo "RESTORED"
      else
        echo "NO_R2_DATA"
      fi
    else
      echo "ALREADY_PRESENT"
    fi
  `);
  const restoreStatus = restoreResult.stdout.trim();
  if (restoreStatus === "RESTORED") {
    console.log("[/ws] Session restored from R2 for:", sessionId);
  } else if (restoreStatus === "ALREADY_PRESENT") {
    console.log("[/ws] Session already in container, skipping R2 restore:", sessionId);
  } else {
    console.log("[/ws] No R2 data to restore for:", sessionId);
  }

  // Start server.ts using startProcess (inherits env vars from setEnvVars)
  const process = await sandbox.startProcess("bun /workspace/server.ts");
  console.log("[/ws] Process started with ID:", process.id);

  // Wait for server to be ready on port 8080
  try {
    await process.waitForPort(8080, { timeout: 30000, path: "/health" });
    console.log("[/ws] Server ready on port 8080");
  } catch (error) {
    console.log("[/ws] Server failed to start:", error);
    const logs = await sandbox.getProcessLogs(process.id);
    console.log("[/ws] Process logs:", logs);
    return c.json(
      {
        error: "Container server failed to start",
        logs: logs,
      },
      503,
    );
  }

  // Proxy the WebSocket connection to the container's server on port 8080
  return sandbox.wsConnect(c.req.raw, 8080);
});

export default app;
export { Sandbox };
